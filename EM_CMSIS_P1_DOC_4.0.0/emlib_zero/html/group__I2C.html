<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Silicon Labs EFM32 emlib Peripheral Library: I2C</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>I2C<br/>
<small>
[<a class="el" href="group__EM__Library.html">EM_Library</a>]</small>
</h1>
<p>Inter-integrated Circuit (I2C) Peripheral API.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for I2C:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__I2C.png" border="0" alt="" usemap="#group____I2C_map"/>
<map name="group____I2C_map" id="group____I2C">
<area shape="rect" id="node2" href="group__EM__Library.html" title="EM_Library" alt="" coords="5,5,96,32"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structI2C__Init__TypeDef.html">I2C_Init_TypeDef</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structI2C__TransferSeq__TypeDef.html">I2C_TransferSeq_TypeDef</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Master mode transfer message structure used to define a complete I2C transfer sequence (from start to stop).  <a href="structI2C__TransferSeq__TypeDef.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga0a2167eb1e00a8da86bf0826f712f0f8">I2C_FREQ_STANDARD_MAX</a>&nbsp;&nbsp;&nbsp;93000</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Standard mode max frequency assuming using 4:4 ratio for Nlow:Nhigh.  <a href="#ga0a2167eb1e00a8da86bf0826f712f0f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga29a3fbc14b30b68601118a9866e7440d">I2C_FREQ_FAST_MAX</a>&nbsp;&nbsp;&nbsp;392157</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast mode max frequency assuming using 6:3 ratio for Nlow:Nhigh.  <a href="#ga29a3fbc14b30b68601118a9866e7440d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga6961334be5d2f1d6e98d8f48de3b040e">I2C_FREQ_FASTPLUS_MAX</a>&nbsp;&nbsp;&nbsp;987167</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast mode+ max frequency assuming using 11:6 ratio for Nlow:Nhigh.  <a href="#ga6961334be5d2f1d6e98d8f48de3b040e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga091476f45133e8a6deb9dbd7a3ea6229">I2C_FLAG_WRITE</a>&nbsp;&nbsp;&nbsp;0x0001</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicate plain write sequence: S+ADDR(W)+DATA0+P.  <a href="#ga091476f45133e8a6deb9dbd7a3ea6229"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga0c1779663a5ebf44e956ea3f591b4e61">I2C_FLAG_READ</a>&nbsp;&nbsp;&nbsp;0x0002</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicate plain read sequence: S+ADDR(R)+DATA0+P.  <a href="#ga0c1779663a5ebf44e956ea3f591b4e61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaf9fc47d6ee1c66405dc491f7a4c3b8fc">I2C_FLAG_WRITE_READ</a>&nbsp;&nbsp;&nbsp;0x0004</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicate combined write/read sequence: S+ADDR(W)+DATA0+Sr+ADDR(R)+DATA1+P.  <a href="#gaf9fc47d6ee1c66405dc491f7a4c3b8fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga28bb5f9d0559f3af24c0554e497ba2b3">I2C_FLAG_WRITE_WRITE</a>&nbsp;&nbsp;&nbsp;0x0008</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicate write sequence using two buffers: S+ADDR(W)+DATA0+DATA1+P.  <a href="#ga28bb5f9d0559f3af24c0554e497ba2b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga6fd13e29a6b6315de051549037ac176f">I2C_FLAG_10BIT_ADDR</a>&nbsp;&nbsp;&nbsp;0x0010</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga5c7fbd27ef311914288d8e7ce02f1528">I2C_INIT_DEFAULT</a></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gabb1516548b4528328682d6be09a3e3a5">I2C_ClockHLR_TypeDef</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__I2C.html#ggabb1516548b4528328682d6be09a3e3a5a72c81018da3424addf47b44341acd111">i2cClockHLRStandard</a> =  _I2C_CTRL_CLHR_STANDARD, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__I2C.html#ggabb1516548b4528328682d6be09a3e3a5a7bfc41c09113d46c1247b598c80a3b2e">i2cClockHLRAsymetric</a> =  _I2C_CTRL_CLHR_ASYMMETRIC, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__I2C.html#ggabb1516548b4528328682d6be09a3e3a5a177d1faa325c634cbf56d2a4b4de9425">i2cClockHLRFast</a> =  _I2C_CTRL_CLHR_FAST
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga7c781ec28ae11e3e28892de7aa07a00f">I2C_TransferReturn_TypeDef</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa1f1df5a76a71b423083d6a327d38ca1c">i2cTransferInProgress</a> =  1, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa01149f9a11ada8a9b05e7104f873de66">i2cTransferDone</a> =  0, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa54895c4189c89f4410a3ce1a15822725">i2cTransferNack</a> =  -1, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa75da099dd69e053ee12d38fdd76a22e6">i2cTransferBusErr</a> =  -2, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fac15d6d57e2c8b0fca04fc6fbd80b824e">i2cTransferArbLost</a> =  -3, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa49fe8ab19b9167d78c4b2abec7a511fc">i2cTransferUsageFault</a> =  -4, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00faa5de823251279b281dcabbd1ec4f693d">i2cTransferSwFault</a> =  -5
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaf2563ff04d4b24825a6c67f9ec4dcb80">I2C_BusFreqGet</a> (I2C_TypeDef *i2c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get current configured I2C bus frequency.  <a href="#gaf2563ff04d4b24825a6c67f9ec4dcb80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga2c0e3b79d2855fd85d4a29a469bbf2ff">I2C_BusFreqSet</a> (I2C_TypeDef *i2c, uint32_t refFreq, uint32_t freq, <a class="el" href="group__I2C.html#gabb1516548b4528328682d6be09a3e3a5">I2C_ClockHLR_TypeDef</a> type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set I2C bus frequency.  <a href="#ga2c0e3b79d2855fd85d4a29a469bbf2ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaca1c9ca46d6945a4696f8a34ab8c2ddf">I2C_Enable</a> (I2C_TypeDef *i2c, bool enable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable/disable I2C.  <a href="#gaca1c9ca46d6945a4696f8a34ab8c2ddf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gab52e0fc0d3690e40f80a193d5b6fdd51">I2C_Init</a> (I2C_TypeDef *i2c, const <a class="el" href="structI2C__Init__TypeDef.html">I2C_Init_TypeDef</a> *init)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize I2C.  <a href="#gab52e0fc0d3690e40f80a193d5b6fdd51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga928527f7065f6b8d4a2bb282bbf8b7cd">I2C_IntClear</a> (I2C_TypeDef *i2c, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear one or more pending I2C interrupts.  <a href="#ga928527f7065f6b8d4a2bb282bbf8b7cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaa11c438128e5fa1d5860d0b7ad88fbfe">I2C_IntDisable</a> (I2C_TypeDef *i2c, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable one or more I2C interrupts.  <a href="#gaa11c438128e5fa1d5860d0b7ad88fbfe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga0b472a05a39a4e1a94d6b1d6270b7aa1">I2C_IntEnable</a> (I2C_TypeDef *i2c, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable one or more I2C interrupts.  <a href="#ga0b472a05a39a4e1a94d6b1d6270b7aa1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga6339175b1242ccf52567f43b969153c1">I2C_IntGet</a> (I2C_TypeDef *i2c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get pending I2C interrupt flags.  <a href="#ga6339175b1242ccf52567f43b969153c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gab6d23302ba9e55d10ee19f20d91f170d">I2C_IntSet</a> (I2C_TypeDef *i2c, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set one or more pending I2C interrupts from SW.  <a href="#gab6d23302ba9e55d10ee19f20d91f170d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga602a1d2c64c05453bf9c1b1d52194678">I2C_Reset</a> (I2C_TypeDef *i2c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset I2C to same state as after a HW reset.  <a href="#ga602a1d2c64c05453bf9c1b1d52194678"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga18042cf363fe66fb94fcd724d07efad2">I2C_SlaveAddressGet</a> (I2C_TypeDef *i2c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get slave address used for I2C peripheral (when operating in slave mode).  <a href="#ga18042cf363fe66fb94fcd724d07efad2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga6d7459b4e89456387a9ea5576612b01d">I2C_SlaveAddressSet</a> (I2C_TypeDef *i2c, uint8_t addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set slave address to use for I2C peripheral (when operating in slave mode).  <a href="#ga6d7459b4e89456387a9ea5576612b01d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga0a0296ee95a311687feea28bac21d1ff">I2C_SlaveAddressMaskGet</a> (I2C_TypeDef *i2c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get slave address mask used for I2C peripheral (when operating in slave mode).  <a href="#ga0a0296ee95a311687feea28bac21d1ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga9ac1d9e8ab3c9303cfabaafe407b5b1e">I2C_SlaveAddressMaskSet</a> (I2C_TypeDef *i2c, uint8_t mask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set slave address mask used for I2C peripheral (when operating in slave mode).  <a href="#ga9ac1d9e8ab3c9303cfabaafe407b5b1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__I2C.html#ga7c781ec28ae11e3e28892de7aa07a00f">I2C_TransferReturn_TypeDef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga67983b3dbe7f028a97f765e421b3df56">I2C_Transfer</a> (I2C_TypeDef *i2c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Continue an initiated I2C transfer (single master mode only).  <a href="#ga67983b3dbe7f028a97f765e421b3df56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__I2C.html#ga7c781ec28ae11e3e28892de7aa07a00f">I2C_TransferReturn_TypeDef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gae2bf2ecc3d0c4f55e3511d4871b64b16">I2C_TransferInit</a> (I2C_TypeDef *i2c, <a class="el" href="structI2C__TransferSeq__TypeDef.html">I2C_TransferSeq_TypeDef</a> *seq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare and start an I2C transfer (single master mode only).  <a href="#gae2bf2ecc3d0c4f55e3511d4871b64b16"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Inter-integrated Circuit (I2C) Peripheral API. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga6fd13e29a6b6315de051549037ac176f"></a><!-- doxytag: member="em_i2c.h::I2C_FLAG_10BIT_ADDR" ref="ga6fd13e29a6b6315de051549037ac176f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_FLAG_10BIT_ADDR&nbsp;&nbsp;&nbsp;0x0010</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use 10 bit address. </p>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00156">156</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

<p>Referenced by <a class="el" href="em__i2c_8c_source.html#l00363">I2C_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0c1779663a5ebf44e956ea3f591b4e61"></a><!-- doxytag: member="em_i2c.h::I2C_FLAG_READ" ref="ga0c1779663a5ebf44e956ea3f591b4e61" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_FLAG_READ&nbsp;&nbsp;&nbsp;0x0002</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicate plain read sequence: S+ADDR(R)+DATA0+P. </p>
<ul>
<li>S - Start </li>
<li>ADDR(R) - address with W/R bit set </li>
<li>DATA0 - Data read into buffer with index 0 </li>
<li>P - Stop </li>
</ul>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00129">129</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

<p>Referenced by <a class="el" href="em__i2c_8c_source.html#l00363">I2C_Transfer()</a>, and <a class="el" href="em__i2c_8c_source.html#l00742">I2C_TransferInit()</a>.</p>

</div>
</div>
<a class="anchor" id="ga091476f45133e8a6deb9dbd7a3ea6229"></a><!-- doxytag: member="em_i2c.h::I2C_FLAG_WRITE" ref="ga091476f45133e8a6deb9dbd7a3ea6229" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_FLAG_WRITE&nbsp;&nbsp;&nbsp;0x0001</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicate plain write sequence: S+ADDR(W)+DATA0+P. </p>
<ul>
<li>S - Start </li>
<li>ADDR(W) - address with W/R bit cleared </li>
<li>DATA0 - Data taken from buffer with index 0 </li>
<li>P - Stop </li>
</ul>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00118">118</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

<p>Referenced by <a class="el" href="em__i2c_8c_source.html#l00363">I2C_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf9fc47d6ee1c66405dc491f7a4c3b8fc"></a><!-- doxytag: member="em_i2c.h::I2C_FLAG_WRITE_READ" ref="gaf9fc47d6ee1c66405dc491f7a4c3b8fc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_FLAG_WRITE_READ&nbsp;&nbsp;&nbsp;0x0004</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicate combined write/read sequence: S+ADDR(W)+DATA0+Sr+ADDR(R)+DATA1+P. </p>
<ul>
<li>S - Start </li>
<li>Sr - Repeated start </li>
<li>ADDR(W) - address with W/R bit cleared </li>
<li>ADDR(R) - address with W/R bit set </li>
<li>DATAn - Data written from/read into buffer with index n </li>
<li>P - Stop </li>
</ul>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00142">142</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

<p>Referenced by <a class="el" href="em__i2c_8c_source.html#l00363">I2C_Transfer()</a>, and <a class="el" href="em__i2c_8c_source.html#l00742">I2C_TransferInit()</a>.</p>

</div>
</div>
<a class="anchor" id="ga28bb5f9d0559f3af24c0554e497ba2b3"></a><!-- doxytag: member="em_i2c.h::I2C_FLAG_WRITE_WRITE" ref="ga28bb5f9d0559f3af24c0554e497ba2b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_FLAG_WRITE_WRITE&nbsp;&nbsp;&nbsp;0x0008</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicate write sequence using two buffers: S+ADDR(W)+DATA0+DATA1+P. </p>
<ul>
<li>S - Start </li>
<li>ADDR(W) - address with W/R bit cleared </li>
<li>DATAn - Data written from buffer with index n </li>
<li>P - Stop </li>
</ul>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00153">153</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga29a3fbc14b30b68601118a9866e7440d"></a><!-- doxytag: member="em_i2c.h::I2C_FREQ_FAST_MAX" ref="ga29a3fbc14b30b68601118a9866e7440d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_FREQ_FAST_MAX&nbsp;&nbsp;&nbsp;392157</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fast mode max frequency assuming using 6:3 ratio for Nlow:Nhigh. </p>
<p>From I2C specification: Min Tlow = 1.3us, min Thigh = 0.6us, max Trise=0.3us, max Tfall=0.3us. Since ratio is 6:3, have to use worst case value of Tlow or 2xThigh as base.</p>
<p>1/(Tlow + Thigh + 0.3us + 0.3us) = 1/(1.3 + 0.65 + 0.6)us = 392157Hz </p>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00093">93</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6961334be5d2f1d6e98d8f48de3b040e"></a><!-- doxytag: member="em_i2c.h::I2C_FREQ_FASTPLUS_MAX" ref="ga6961334be5d2f1d6e98d8f48de3b040e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_FREQ_FASTPLUS_MAX&nbsp;&nbsp;&nbsp;987167</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fast mode+ max frequency assuming using 11:6 ratio for Nlow:Nhigh. </p>
<p>From I2C specification: Min Tlow = 0.5us, min Thigh = 0.26us, max Trise=0.12us, max Tfall=0.12us. Since ratio is 11:6, have to use worst case value of Tlow or (11/6)xThigh as base.</p>
<p>1/(Tlow + Thigh + 0.12us + 0.12us) = 1/(0.5 + 0.273 + 0.24)us = 987167Hz </p>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00106">106</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0a2167eb1e00a8da86bf0826f712f0f8"></a><!-- doxytag: member="em_i2c.h::I2C_FREQ_STANDARD_MAX" ref="ga0a2167eb1e00a8da86bf0826f712f0f8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_FREQ_STANDARD_MAX&nbsp;&nbsp;&nbsp;93000</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Standard mode max frequency assuming using 4:4 ratio for Nlow:Nhigh. </p>
<p>From I2C specification: Min Tlow = 4.7us, min Thigh = 4.0us, max Trise=1.0us, max Tfall=0.3us. Since ratio is 4:4, have to use worst case value of Tlow or Thigh as base.</p>
<p>1/(Tlow + Thigh + 1us + 0.3us) = 1/(4.7 + 4.7 + 1.3)us = 93458Hz </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Due to chip characteristics, the max value is somewhat reduced. </dd></dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00074">74</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5c7fbd27ef311914288d8e7ce02f1528"></a><!-- doxytag: member="em_i2c.h::I2C_INIT_DEFAULT" ref="ga5c7fbd27ef311914288d8e7ce02f1528" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_INIT_DEFAULT</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{ <span class="keyword">true</span>,                    <span class="comment">/* Enable when init done */</span>                    \
    <span class="keyword">true</span>,                    <span class="comment">/* Set to master mode */</span>                       \
    0,                       <span class="comment">/* Use currently configured reference clock */</span> \
    <a class="code" href="group__I2C.html#ga0a2167eb1e00a8da86bf0826f712f0f8" title="Standard mode max frequency assuming using 4:4 ratio for Nlow:Nhigh.">I2C_FREQ_STANDARD_MAX</a>,   <span class="comment">/* Set to standard rate assuring being */</span>      \
                             <span class="comment">/* within I2C spec */</span>                          \
    <a class="code" href="group__I2C.html#ggabb1516548b4528328682d6be09a3e3a5a72c81018da3424addf47b44341acd111">i2cClockHLRStandard</a>      <span class="comment">/* Set to use 4:4 low/high duty cycle */</span>       \
  }
</pre></div><p>Suggested default config for I2C init structure. </p>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00221">221</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gabb1516548b4528328682d6be09a3e3a5"></a><!-- doxytag: member="em_i2c.h::I2C_ClockHLR_TypeDef" ref="gabb1516548b4528328682d6be09a3e3a5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__I2C.html#gabb1516548b4528328682d6be09a3e3a5">I2C_ClockHLR_TypeDef</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clock low to high ratio settings. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggabb1516548b4528328682d6be09a3e3a5a72c81018da3424addf47b44341acd111"></a><!-- doxytag: member="i2cClockHLRStandard" ref="ggabb1516548b4528328682d6be09a3e3a5a72c81018da3424addf47b44341acd111" args="" -->i2cClockHLRStandard</em>&nbsp;</td><td>
<p>Ratio is 4:4 </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggabb1516548b4528328682d6be09a3e3a5a7bfc41c09113d46c1247b598c80a3b2e"></a><!-- doxytag: member="i2cClockHLRAsymetric" ref="ggabb1516548b4528328682d6be09a3e3a5a7bfc41c09113d46c1247b598c80a3b2e" args="" -->i2cClockHLRAsymetric</em>&nbsp;</td><td>
<p>Ratio is 6:3 </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggabb1516548b4528328682d6be09a3e3a5a177d1faa325c634cbf56d2a4b4de9425"></a><!-- doxytag: member="i2cClockHLRFast" ref="ggabb1516548b4528328682d6be09a3e3a5a177d1faa325c634cbf56d2a4b4de9425" args="" -->i2cClockHLRFast</em>&nbsp;</td><td>
<p>Ratio is 11:3 </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00164">164</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga7c781ec28ae11e3e28892de7aa07a00f"></a><!-- doxytag: member="em_i2c.h::I2C_TransferReturn_TypeDef" ref="ga7c781ec28ae11e3e28892de7aa07a00f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__I2C.html#ga7c781ec28ae11e3e28892de7aa07a00f">I2C_TransferReturn_TypeDef</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return codes for single master mode transfer function. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga7c781ec28ae11e3e28892de7aa07a00fa1f1df5a76a71b423083d6a327d38ca1c"></a><!-- doxytag: member="i2cTransferInProgress" ref="gga7c781ec28ae11e3e28892de7aa07a00fa1f1df5a76a71b423083d6a327d38ca1c" args="" -->i2cTransferInProgress</em>&nbsp;</td><td>
<p>Transfer in progress. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7c781ec28ae11e3e28892de7aa07a00fa01149f9a11ada8a9b05e7104f873de66"></a><!-- doxytag: member="i2cTransferDone" ref="gga7c781ec28ae11e3e28892de7aa07a00fa01149f9a11ada8a9b05e7104f873de66" args="" -->i2cTransferDone</em>&nbsp;</td><td>
<p>Transfer completed successfully. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7c781ec28ae11e3e28892de7aa07a00fa54895c4189c89f4410a3ce1a15822725"></a><!-- doxytag: member="i2cTransferNack" ref="gga7c781ec28ae11e3e28892de7aa07a00fa54895c4189c89f4410a3ce1a15822725" args="" -->i2cTransferNack</em>&nbsp;</td><td>
<p>NACK received during transfer. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7c781ec28ae11e3e28892de7aa07a00fa75da099dd69e053ee12d38fdd76a22e6"></a><!-- doxytag: member="i2cTransferBusErr" ref="gga7c781ec28ae11e3e28892de7aa07a00fa75da099dd69e053ee12d38fdd76a22e6" args="" -->i2cTransferBusErr</em>&nbsp;</td><td>
<p>Bus error during transfer (misplaced START/STOP). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7c781ec28ae11e3e28892de7aa07a00fac15d6d57e2c8b0fca04fc6fbd80b824e"></a><!-- doxytag: member="i2cTransferArbLost" ref="gga7c781ec28ae11e3e28892de7aa07a00fac15d6d57e2c8b0fca04fc6fbd80b824e" args="" -->i2cTransferArbLost</em>&nbsp;</td><td>
<p>Arbitration lost during transfer. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7c781ec28ae11e3e28892de7aa07a00fa49fe8ab19b9167d78c4b2abec7a511fc"></a><!-- doxytag: member="i2cTransferUsageFault" ref="gga7c781ec28ae11e3e28892de7aa07a00fa49fe8ab19b9167d78c4b2abec7a511fc" args="" -->i2cTransferUsageFault</em>&nbsp;</td><td>
<p>Usage fault. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7c781ec28ae11e3e28892de7aa07a00faa5de823251279b281dcabbd1ec4f693d"></a><!-- doxytag: member="i2cTransferSwFault" ref="gga7c781ec28ae11e3e28892de7aa07a00faa5de823251279b281dcabbd1ec4f693d" args="" -->i2cTransferSwFault</em>&nbsp;</td><td>
<p>SW fault. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00173">173</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaf2563ff04d4b24825a6c67f9ec4dcb80"></a><!-- doxytag: member="em_i2c.h::I2C_BusFreqGet" ref="gaf2563ff04d4b24825a6c67f9ec4dcb80" args="(I2C_TypeDef *i2c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2C_BusFreqGet </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>i2c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get current configured I2C bus frequency. </p>
<p>This frequency is only of relevance when acting as master.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i2c</em>&nbsp;</td><td>Pointer to I2C peripheral register block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current I2C frequency in Hz. </dd></dl>

<p>Definition at line <a class="el" href="em__i2c_8c_source.html#l00160">160</a> of file <a class="el" href="em__i2c_8c_source.html">em_i2c.c</a>.</p>

<p>References <a class="el" href="em__cmu_8c_source.html#l01123">CMU_ClockFreqGet()</a>, and <a class="el" href="em__cmu_8h_source.html#l00249">cmuClock_HFPER</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__I2C_gaf2563ff04d4b24825a6c67f9ec4dcb80_cgraph.png" border="0" usemap="#group__I2C_gaf2563ff04d4b24825a6c67f9ec4dcb80_cgraph_map" alt=""></div>
<map name="group__I2C_gaf2563ff04d4b24825a6c67f9ec4dcb80_cgraph_map" id="group__I2C_gaf2563ff04d4b24825a6c67f9ec4dcb80_cgraph">
<area shape="rect" id="node2" href="group__CMU.html#gac9aa0ed17f83bd48abcf7b430843374a" title="Get clock frequency for a clock point." alt="" coords="176,5,320,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga2c0e3b79d2855fd85d4a29a469bbf2ff"></a><!-- doxytag: member="em_i2c.h::I2C_BusFreqSet" ref="ga2c0e3b79d2855fd85d4a29a469bbf2ff" args="(I2C_TypeDef *i2c, uint32_t refFreq, uint32_t freq, I2C_ClockHLR_TypeDef type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_BusFreqSet </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>refFreq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__I2C.html#gabb1516548b4528328682d6be09a3e3a5">I2C_ClockHLR_TypeDef</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set I2C bus frequency. </p>
<p>The bus frequency is only of relevance when acting as a master. The bus frequency should not be set higher than the max frequency accepted by the slowest device on the bus.</p>
<p>Notice that due to asymmetric requirements on low and high I2C clock cycles by the I2C specification, the actual max frequency allowed in order to comply with the specification may be somewhat lower than expected.</p>
<p>Please refer to the reference manual, details on I2C clock generation, for max allowed theoretical frequencies for different modes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i2c</em>&nbsp;</td><td>Pointer to I2C peripheral register block.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refFreq</em>&nbsp;</td><td>I2C reference clock frequency in Hz that will be used. If set to 0, the currently configured reference clock is assumed. Setting it to a higher than actual configured value only has the consequence of reducing the real I2C frequency.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>freq</em>&nbsp;</td><td>Bus frequency to set (actual bus speed may be lower due to integer prescaling). Safe (according to I2C specification) max frequencies for standard, fast and fast+ modes are available using I2C_FREQ_ defines. (Using I2C_FREQ_ defines requires corresponding setting of <code>type</code>.) Slowest slave device on bus must always be considered.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>Clock low to high ratio type to use. If not using i2cClockHLRStandard, make sure all devices on the bus support the specified mode. Using a non-standard ratio is useful to achieve higher bus clock in fast and fast+ modes. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8c_source.html#l00211">211</a> of file <a class="el" href="em__i2c_8c_source.html">em_i2c.c</a>.</p>

<p>References <a class="el" href="em__cmu_8c_source.html#l01123">CMU_ClockFreqGet()</a>, and <a class="el" href="em__cmu_8h_source.html#l00249">cmuClock_HFPER</a>.</p>

<p>Referenced by <a class="el" href="em__i2c_8c_source.html#l00284">I2C_Init()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__I2C_ga2c0e3b79d2855fd85d4a29a469bbf2ff_cgraph.png" border="0" usemap="#group__I2C_ga2c0e3b79d2855fd85d4a29a469bbf2ff_cgraph_map" alt=""></div>
<map name="group__I2C_ga2c0e3b79d2855fd85d4a29a469bbf2ff_cgraph_map" id="group__I2C_ga2c0e3b79d2855fd85d4a29a469bbf2ff_cgraph">
<area shape="rect" id="node2" href="group__CMU.html#gac9aa0ed17f83bd48abcf7b430843374a" title="Get clock frequency for a clock point." alt="" coords="176,5,320,32"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__I2C_ga2c0e3b79d2855fd85d4a29a469bbf2ff_icgraph.png" border="0" usemap="#group__I2C_ga2c0e3b79d2855fd85d4a29a469bbf2ff_icgraph_map" alt=""></div>
<map name="group__I2C_ga2c0e3b79d2855fd85d4a29a469bbf2ff_icgraph_map" id="group__I2C_ga2c0e3b79d2855fd85d4a29a469bbf2ff_icgraph">
<area shape="rect" id="node2" href="group__I2C.html#gab52e0fc0d3690e40f80a193d5b6fdd51" title="Initialize I2C." alt="" coords="177,5,245,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaca1c9ca46d6945a4696f8a34ab8c2ddf"></a><!-- doxytag: member="em_i2c.h::I2C_Enable" ref="gaca1c9ca46d6945a4696f8a34ab8c2ddf" args="(I2C_TypeDef *i2c, bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_Enable </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable/disable I2C. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>After enabling the I2C (from being disabled), the I2C is in BUSY state.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i2c</em>&nbsp;</td><td>Pointer to I2C peripheral register block.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>enable</em>&nbsp;</td><td>true to enable counting, false to disable. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8c_source.html#l00266">266</a> of file <a class="el" href="em__i2c_8c_source.html">em_i2c.c</a>.</p>

<p>References <a class="el" href="em__bitband_8h_source.html#l00071">BITBAND_Peripheral()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__I2C_gaca1c9ca46d6945a4696f8a34ab8c2ddf_cgraph.png" border="0" usemap="#group__I2C_gaca1c9ca46d6945a4696f8a34ab8c2ddf_cgraph_map" alt=""></div>
<map name="group__I2C_gaca1c9ca46d6945a4696f8a34ab8c2ddf_cgraph_map" id="group__I2C_gaca1c9ca46d6945a4696f8a34ab8c2ddf_cgraph">
<area shape="rect" id="node2" href="group__BITBAND.html#ga7df78ffd2c201e674a4444c42b6fcec3" title="Perform bit&#45;band operation on peripheral memory location." alt="" coords="147,5,293,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gab52e0fc0d3690e40f80a193d5b6fdd51"></a><!-- doxytag: member="em_i2c.h::I2C_Init" ref="gab52e0fc0d3690e40f80a193d5b6fdd51" args="(I2C_TypeDef *i2c, const I2C_Init_TypeDef *init)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_Init </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structI2C__Init__TypeDef.html">I2C_Init_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>init</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize I2C. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i2c</em>&nbsp;</td><td>Pointer to I2C peripheral register block.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>init</em>&nbsp;</td><td>Pointer to I2C initialization structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8c_source.html#l00284">284</a> of file <a class="el" href="em__i2c_8c_source.html">em_i2c.c</a>.</p>

<p>References <a class="el" href="em__bitband_8h_source.html#l00071">BITBAND_Peripheral()</a>, <a class="el" href="em__i2c_8h_source.html#l00217">I2C_Init_TypeDef::clhr</a>, <a class="el" href="em__i2c_8h_source.html#l00198">I2C_Init_TypeDef::enable</a>, <a class="el" href="em__i2c_8h_source.html#l00214">I2C_Init_TypeDef::freq</a>, <a class="el" href="em__i2c_8c_source.html#l00211">I2C_BusFreqSet()</a>, <a class="el" href="em__i2c_8h_source.html#l00201">I2C_Init_TypeDef::master</a>, and <a class="el" href="em__i2c_8h_source.html#l00208">I2C_Init_TypeDef::refFreq</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__I2C_gab52e0fc0d3690e40f80a193d5b6fdd51_cgraph.png" border="0" usemap="#group__I2C_gab52e0fc0d3690e40f80a193d5b6fdd51_cgraph_map" alt=""></div>
<map name="group__I2C_gab52e0fc0d3690e40f80a193d5b6fdd51_cgraph_map" id="group__I2C_gab52e0fc0d3690e40f80a193d5b6fdd51_cgraph">
<area shape="rect" id="node2" href="group__BITBAND.html#ga7df78ffd2c201e674a4444c42b6fcec3" title="Perform bit&#45;band operation on peripheral memory location." alt="" coords="123,5,269,32"/><area shape="rect" id="node3" href="group__I2C.html#ga2c0e3b79d2855fd85d4a29a469bbf2ff" title="Set I2C bus frequency." alt="" coords="135,56,257,83"/><area shape="rect" id="node4" href="group__CMU.html#gac9aa0ed17f83bd48abcf7b430843374a" title="Get clock frequency for a clock point." alt="" coords="317,56,461,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga928527f7065f6b8d4a2bb282bbf8b7cd"></a><!-- doxytag: member="em_i2c.h::I2C_IntClear" ref="ga928527f7065f6b8d4a2bb282bbf8b7cd" args="(I2C_TypeDef *i2c, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void I2C_IntClear </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear one or more pending I2C interrupts. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i2c</em>&nbsp;</td><td>Pointer to I2C peripheral register block.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Pending I2C interrupt source to clear. Use a bitwse logic OR combination of valid interrupt flags for the I2C module (I2C_IF_nnn). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00304">304</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa11c438128e5fa1d5860d0b7ad88fbfe"></a><!-- doxytag: member="em_i2c.h::I2C_IntDisable" ref="gaa11c438128e5fa1d5860d0b7ad88fbfe" args="(I2C_TypeDef *i2c, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void I2C_IntDisable </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable one or more I2C interrupts. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i2c</em>&nbsp;</td><td>Pointer to I2C peripheral register block.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>I2C interrupt sources to disable. Use a bitwise logic OR combination of valid interrupt flags for the I2C module (I2C_IF_nnn). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00321">321</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0b472a05a39a4e1a94d6b1d6270b7aa1"></a><!-- doxytag: member="em_i2c.h::I2C_IntEnable" ref="ga0b472a05a39a4e1a94d6b1d6270b7aa1" args="(I2C_TypeDef *i2c, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void I2C_IntEnable </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable one or more I2C interrupts. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Depending on the use, a pending interrupt may already be set prior to enabling the interrupt. Consider using <a class="el" href="group__I2C.html#ga928527f7065f6b8d4a2bb282bbf8b7cd" title="Clear one or more pending I2C interrupts.">I2C_IntClear()</a> prior to enabling if such a pending interrupt should be ignored.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i2c</em>&nbsp;</td><td>Pointer to I2C peripheral register block.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>I2C interrupt sources to enable. Use a bitwise logic OR combination of valid interrupt flags for the I2C module (I2C_IF_nnn). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00343">343</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6339175b1242ccf52567f43b969153c1"></a><!-- doxytag: member="em_i2c.h::I2C_IntGet" ref="ga6339175b1242ccf52567f43b969153c1" args="(I2C_TypeDef *i2c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t I2C_IntGet </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>i2c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get pending I2C interrupt flags. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The event bits are not cleared by the use of this function.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i2c</em>&nbsp;</td><td>Pointer to I2C peripheral register block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>I2C interrupt sources pending. A bitwise logic OR combination of valid interrupt flags for the I2C module (I2C_IF_nnn). </dd></dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00363">363</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab6d23302ba9e55d10ee19f20d91f170d"></a><!-- doxytag: member="em_i2c.h::I2C_IntSet" ref="gab6d23302ba9e55d10ee19f20d91f170d" args="(I2C_TypeDef *i2c, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void I2C_IntSet </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set one or more pending I2C interrupts from SW. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i2c</em>&nbsp;</td><td>Pointer to I2C peripheral register block.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>I2C interrupt sources to set to pending. Use a bitwise logic OR combination of valid interrupt flags for the I2C module (I2C_IF_nnn). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00380">380</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga602a1d2c64c05453bf9c1b1d52194678"></a><!-- doxytag: member="em_i2c.h::I2C_Reset" ref="ga602a1d2c64c05453bf9c1b1d52194678" args="(I2C_TypeDef *i2c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_Reset </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>i2c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset I2C to same state as after a HW reset. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The ROUTE register is NOT reset by this function, in order to allow for centralized setup of this feature.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i2c</em>&nbsp;</td><td>Pointer to I2C peripheral register block. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8c_source.html#l00315">315</a> of file <a class="el" href="em__i2c_8c_source.html">em_i2c.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga18042cf363fe66fb94fcd724d07efad2"></a><!-- doxytag: member="em_i2c.h::I2C_SlaveAddressGet" ref="ga18042cf363fe66fb94fcd724d07efad2" args="(I2C_TypeDef *i2c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint8_t I2C_SlaveAddressGet </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>i2c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get slave address used for I2C peripheral (when operating in slave mode). </p>
<p>For 10 bit addressing mode, the address is split in two bytes, and only the first byte setting is fetched, effectively only controlling the 2 most significant bits of the 10 bit address. Full handling of 10 bit addressing in slave mode requires additional SW handling.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i2c</em>&nbsp;</td><td>Pointer to I2C peripheral register block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>I2C slave address in use. The 7 most significant bits define the actual address, the least significant bit is reserved and always returned as 0. </dd></dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00404">404</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0a0296ee95a311687feea28bac21d1ff"></a><!-- doxytag: member="em_i2c.h::I2C_SlaveAddressMaskGet" ref="ga0a0296ee95a311687feea28bac21d1ff" args="(I2C_TypeDef *i2c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint8_t I2C_SlaveAddressMaskGet </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>i2c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get slave address mask used for I2C peripheral (when operating in slave mode). </p>
<p>The address mask defines how the comparator works. A bit position with value 0 means that the corresponding slave address bit is ignored during comparison (don't care). A bit position with value 1 means that the corresponding slave address bit must match.</p>
<p>For 10 bit addressing mode, the address is split in two bytes, and only the mask for the first address byte is fetched, effectively only controlling the 2 most significant bits of the 10 bit address.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i2c</em>&nbsp;</td><td>Pointer to I2C peripheral register block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>I2C slave address mask in use. The 7 most significant bits define the actual address mask, the least significant bit is reserved and always returned as 0. </dd></dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00456">456</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga9ac1d9e8ab3c9303cfabaafe407b5b1e"></a><!-- doxytag: member="em_i2c.h::I2C_SlaveAddressMaskSet" ref="ga9ac1d9e8ab3c9303cfabaafe407b5b1e" args="(I2C_TypeDef *i2c, uint8_t mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void I2C_SlaveAddressMaskSet </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set slave address mask used for I2C peripheral (when operating in slave mode). </p>
<p>The address mask defines how the comparator works. A bit position with value 0 means that the corresponding slave address bit is ignored during comparison (don't care). A bit position with value 1 means that the corresponding slave address bit must match.</p>
<p>For 10 bit addressing mode, the address is split in two bytes, and only the mask for the first address byte is set, effectively only controlling the 2 most significant bits of the 10 bit address.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i2c</em>&nbsp;</td><td>Pointer to I2C peripheral register block.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mask</em>&nbsp;</td><td>I2C slave address mask to use. The 7 most significant bits define the actual address mask, the least significant bit is reserved and should be 0. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00485">485</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6d7459b4e89456387a9ea5576612b01d"></a><!-- doxytag: member="em_i2c.h::I2C_SlaveAddressSet" ref="ga6d7459b4e89456387a9ea5576612b01d" args="(I2C_TypeDef *i2c, uint8_t addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void I2C_SlaveAddressSet </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set slave address to use for I2C peripheral (when operating in slave mode). </p>
<p>For 10 bit addressing mode, the address is split in two bytes, and only the first byte is set, effectively only controlling the 2 most significant bits of the 10 bit address. Full handling of 10 bit addressing in slave mode requires additional SW handling.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i2c</em>&nbsp;</td><td>Pointer to I2C peripheral register block.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>I2C slave address to use. The 7 most significant bits define the actual address, the least significant bit is reserved and always set to 0. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00427">427</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga67983b3dbe7f028a97f765e421b3df56"></a><!-- doxytag: member="em_i2c.h::I2C_Transfer" ref="ga67983b3dbe7f028a97f765e421b3df56" args="(I2C_TypeDef *i2c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__I2C.html#ga7c781ec28ae11e3e28892de7aa07a00f">I2C_TransferReturn_TypeDef</a> I2C_Transfer </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>i2c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Continue an initiated I2C transfer (single master mode only). </p>
<p>This function is used repeatedly after a <a class="el" href="group__I2C.html#gae2bf2ecc3d0c4f55e3511d4871b64b16" title="Prepare and start an I2C transfer (single master mode only).">I2C_TransferInit()</a> in order to complete a transfer. It may be used in polled mode as the below example shows: </p>
<div class="fragment"><pre class="fragment">
 * I2C_TransferReturn_TypeDef ret;
 *
 * // Do a polled transfer
 * ret = I2C_TransferInit(I2C0, seq);
 * while (ret == i2cTransferInProgress)
 * {
 *   ret = I2C_Transfer(I2C0);
 * }
 * </pre></div><p> It may also be used in interrupt driven mode, where this function is invoked from the interrupt handler. Notice that if used in interrupt mode, NVIC interrupts must be configured and enabled for the I2C bus used. I2C peripheral specific interrupts are managed by this SW.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Only single master mode is supported.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i2c</em>&nbsp;</td><td>Pointer to I2C peripheral register block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns status for ongoing transfer. <ul>
<li><a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa1f1df5a76a71b423083d6a327d38ca1c">i2cTransferInProgress</a> - indicates that transfer not finished. </li>
<li><a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa01149f9a11ada8a9b05e7104f873de66">i2cTransferDone</a> - transfer completed successfully. </li>
<li>otherwise some sort of error has occurred. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="em__i2c_8c_source.html#l00363">363</a> of file <a class="el" href="em__i2c_8c_source.html">em_i2c.c</a>.</p>

<p>References <a class="el" href="em__i2c_8h_source.html#l00255">I2C_TransferSeq_TypeDef::addr</a>, <a class="el" href="structI2C__TransferSeq__TypeDef.html#a8768a91a4d0d3c66e72e8fdb981b5c63">I2C_TransferSeq_TypeDef::buf</a>, <a class="el" href="em__i2c_8h_source.html#l00267">I2C_TransferSeq_TypeDef::data</a>, <a class="el" href="em__i2c_8h_source.html#l00258">I2C_TransferSeq_TypeDef::flags</a>, <a class="el" href="em__i2c_8h_source.html#l00156">I2C_FLAG_10BIT_ADDR</a>, <a class="el" href="em__i2c_8h_source.html#l00129">I2C_FLAG_READ</a>, <a class="el" href="em__i2c_8h_source.html#l00118">I2C_FLAG_WRITE</a>, <a class="el" href="em__i2c_8h_source.html#l00142">I2C_FLAG_WRITE_READ</a>, <a class="el" href="em__i2c_8h_source.html#l00184">i2cTransferArbLost</a>, <a class="el" href="em__i2c_8h_source.html#l00183">i2cTransferBusErr</a>, <a class="el" href="em__i2c_8h_source.html#l00179">i2cTransferDone</a>, <a class="el" href="em__i2c_8h_source.html#l00176">i2cTransferInProgress</a>, <a class="el" href="em__i2c_8h_source.html#l00182">i2cTransferNack</a>, <a class="el" href="em__i2c_8h_source.html#l00186">i2cTransferSwFault</a>, <a class="el" href="em__i2c_8h_source.html#l00185">i2cTransferUsageFault</a>, and <a class="el" href="em__i2c_8h_source.html#l00276">I2C_TransferSeq_TypeDef::len</a>.</p>

<p>Referenced by <a class="el" href="em__i2c_8c_source.html#l00742">I2C_TransferInit()</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__I2C_ga67983b3dbe7f028a97f765e421b3df56_icgraph.png" border="0" usemap="#group__I2C_ga67983b3dbe7f028a97f765e421b3df56_icgraph_map" alt=""></div>
<map name="group__I2C_ga67983b3dbe7f028a97f765e421b3df56_icgraph_map" id="group__I2C_ga67983b3dbe7f028a97f765e421b3df56_icgraph">
<area shape="rect" id="node2" href="group__I2C.html#gae2bf2ecc3d0c4f55e3511d4871b64b16" title="Prepare and start an I2C transfer (single master mode only)." alt="" coords="158,5,279,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gae2bf2ecc3d0c4f55e3511d4871b64b16"></a><!-- doxytag: member="em_i2c.h::I2C_TransferInit" ref="gae2bf2ecc3d0c4f55e3511d4871b64b16" args="(I2C_TypeDef *i2c, I2C_TransferSeq_TypeDef *seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__I2C.html#ga7c781ec28ae11e3e28892de7aa07a00f">I2C_TransferReturn_TypeDef</a> I2C_TransferInit </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structI2C__TransferSeq__TypeDef.html">I2C_TransferSeq_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>seq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare and start an I2C transfer (single master mode only). </p>
<p>This function must be invoked in order to start an I2C transfer sequence. In order to actually complete the transfer, <a class="el" href="group__I2C.html#ga67983b3dbe7f028a97f765e421b3df56" title="Continue an initiated I2C transfer (single master mode only).">I2C_Transfer()</a> must be used either in polled mode or by adding a small driver wrapper utilizing interrupts.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Only single master mode is supported.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i2c</em>&nbsp;</td><td>Pointer to I2C peripheral register block.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>seq</em>&nbsp;</td><td>Pointer to sequence structure defining the I2C transfer to take place. The referenced structure must exist until the transfer has fully completed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns status for ongoing transfer: <ul>
<li><a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa1f1df5a76a71b423083d6a327d38ca1c">i2cTransferInProgress</a> - indicates that transfer not finished. </li>
<li>otherwise some sort of error has occurred. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="em__i2c_8c_source.html#l00742">742</a> of file <a class="el" href="em__i2c_8c_source.html">em_i2c.c</a>.</p>

<p>References <a class="el" href="structI2C__TransferSeq__TypeDef.html#a8768a91a4d0d3c66e72e8fdb981b5c63">I2C_TransferSeq_TypeDef::buf</a>, <a class="el" href="em__i2c_8h_source.html#l00258">I2C_TransferSeq_TypeDef::flags</a>, <a class="el" href="em__i2c_8h_source.html#l00129">I2C_FLAG_READ</a>, <a class="el" href="em__i2c_8h_source.html#l00142">I2C_FLAG_WRITE_READ</a>, <a class="el" href="em__i2c_8c_source.html#l00363">I2C_Transfer()</a>, <a class="el" href="em__i2c_8h_source.html#l00176">i2cTransferInProgress</a>, <a class="el" href="em__i2c_8h_source.html#l00185">i2cTransferUsageFault</a>, and <a class="el" href="em__i2c_8h_source.html#l00276">I2C_TransferSeq_TypeDef::len</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__I2C_gae2bf2ecc3d0c4f55e3511d4871b64b16_cgraph.png" border="0" usemap="#group__I2C_gae2bf2ecc3d0c4f55e3511d4871b64b16_cgraph_map" alt=""></div>
<map name="group__I2C_gae2bf2ecc3d0c4f55e3511d4871b64b16_cgraph_map" id="group__I2C_gae2bf2ecc3d0c4f55e3511d4871b64b16_cgraph">
<area shape="rect" id="node2" href="group__I2C.html#ga67983b3dbe7f028a97f765e421b3df56" title="Continue an initiated I2C transfer (single master mode only)." alt="" coords="177,5,279,32"/></map>
</div>
</p>

</div>
</div>
</div>
<div id="footer">
<hr size="1"><address style="text-align: right;"><small>
Generated on Thu May 28 06:11:29 2015</small> for Silicon Labs EFM32 emlib Peripheral Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a><small> 1.6.3 </small></address></div>
</body>
</html>
