<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Silicon Labs EFM32 emlib Peripheral Library: LETIMER</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>LETIMER<br/>
<small>
[<a class="el" href="group__EM__Library.html">EM_Library</a>]</small>
</h1>
<p>Low Energy Timer (LETIMER) Peripheral API.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for LETIMER:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__LETIMER.png" border="0" alt="" usemap="#group____LETIMER_map"/>
<map name="group____LETIMER_map" id="group____LETIMER">
<area shape="rect" id="node2" href="group__EM__Library.html" title="EM_Library" alt="" coords="5,5,96,32"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLETIMER__Init__TypeDef.html">LETIMER_Init_TypeDef</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LETIMER.html#gaa409061c5239d936cd67b4d578c054b3">LETIMER_INIT_DEFAULT</a></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LETIMER.html#ga621d39064a03e229a02e2c33fd815eb2">LETIMER_RepeatMode_TypeDef</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__LETIMER.html#gga621d39064a03e229a02e2c33fd815eb2aecd049f93ca363cf8c8c4569ad811a9b">letimerRepeatFree</a> =  _LETIMER_CTRL_REPMODE_FREE, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__LETIMER.html#gga621d39064a03e229a02e2c33fd815eb2a63dd96017a9e751c8cf5bfbd6ad9cf25">letimerRepeatOneshot</a> =  _LETIMER_CTRL_REPMODE_ONESHOT, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__LETIMER.html#gga621d39064a03e229a02e2c33fd815eb2a7bc26aed4618fc9209e44d40435aa05d">letimerRepeatBuffered</a> =  _LETIMER_CTRL_REPMODE_BUFFERED, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__LETIMER.html#gga621d39064a03e229a02e2c33fd815eb2a80f3d6cab367aa9ab2e153176bbecf00">letimerRepeatDouble</a> =  _LETIMER_CTRL_REPMODE_DOUBLE
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LETIMER.html#ga7e794807b846cd4764aa5ff96e259ba7">LETIMER_UFOA_TypeDef</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__LETIMER.html#gga7e794807b846cd4764aa5ff96e259ba7a265c11a5fd587fa4abb5a92253152a32">letimerUFOANone</a> =  _LETIMER_CTRL_UFOA0_NONE, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__LETIMER.html#gga7e794807b846cd4764aa5ff96e259ba7ab5fab86cea7ea60d6a614c1cd85febce">letimerUFOAToggle</a> =  _LETIMER_CTRL_UFOA0_TOGGLE, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__LETIMER.html#gga7e794807b846cd4764aa5ff96e259ba7a7a3c257077a97dfc45a3020892f0120f">letimerUFOAPulse</a> =  _LETIMER_CTRL_UFOA0_PULSE, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__LETIMER.html#gga7e794807b846cd4764aa5ff96e259ba7aa0547d98df77e356629131291036f787">letimerUFOAPwm</a> =  _LETIMER_CTRL_UFOA0_PWM
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LETIMER.html#ga8def6260e3c54ec6dac11581dcd7c1c5">LETIMER_CompareGet</a> (LETIMER_TypeDef *letimer, unsigned int comp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get LETIMER compare register value.  <a href="#ga8def6260e3c54ec6dac11581dcd7c1c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LETIMER.html#ga5881f97abb64700592a23e213edeba21">LETIMER_CompareSet</a> (LETIMER_TypeDef *letimer, unsigned int comp, uint32_t value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set LETIMER compare register value.  <a href="#ga5881f97abb64700592a23e213edeba21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LETIMER.html#ga50ca4ff31c5eee289cb249fd160683f2">LETIMER_CounterGet</a> (LETIMER_TypeDef *letimer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get LETIMER counter value.  <a href="#ga50ca4ff31c5eee289cb249fd160683f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LETIMER.html#gaca64117c08fbb558eb2feb300cef0621">LETIMER_Enable</a> (LETIMER_TypeDef *letimer, bool enable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start/stop LETIMER.  <a href="#gaca64117c08fbb558eb2feb300cef0621"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LETIMER.html#gaf4a565497669b1852de043374173c288">LETIMER_FreezeEnable</a> (LETIMER_TypeDef *letimer, bool enable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LETIMER register synchronization freeze control.  <a href="#gaf4a565497669b1852de043374173c288"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LETIMER.html#gaa4e7e28b4b04595a991a93b9e76c9919">LETIMER_Init</a> (LETIMER_TypeDef *letimer, const <a class="el" href="structLETIMER__Init__TypeDef.html">LETIMER_Init_TypeDef</a> *init)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize LETIMER.  <a href="#gaa4e7e28b4b04595a991a93b9e76c9919"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LETIMER.html#ga73948168b9c0345e75551ed3f8115474">LETIMER_IntClear</a> (LETIMER_TypeDef *letimer, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear one or more pending LETIMER interrupts.  <a href="#ga73948168b9c0345e75551ed3f8115474"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LETIMER.html#gac559ba136bfd11379a1dc12cc45cc82e">LETIMER_IntDisable</a> (LETIMER_TypeDef *letimer, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable one or more LETIMER interrupts.  <a href="#gac559ba136bfd11379a1dc12cc45cc82e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LETIMER.html#ga11110bb53b566e017a9248a4a8946963">LETIMER_IntEnable</a> (LETIMER_TypeDef *letimer, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable one or more LETIMER interrupts.  <a href="#ga11110bb53b566e017a9248a4a8946963"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LETIMER.html#gafc3fe4be7e3a67c4403c0c0a9966a893">LETIMER_IntGet</a> (LETIMER_TypeDef *letimer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get pending LETIMER interrupt flags.  <a href="#gafc3fe4be7e3a67c4403c0c0a9966a893"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LETIMER.html#ga8ad490c965b096e4bde9ebdc2a16ec05">LETIMER_IntSet</a> (LETIMER_TypeDef *letimer, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set one or more pending LETIMER interrupts from SW.  <a href="#ga8ad490c965b096e4bde9ebdc2a16ec05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LETIMER.html#ga8012c191a62ae300457d246f6fd13c04">LETIMER_RepeatGet</a> (LETIMER_TypeDef *letimer, unsigned int rep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get LETIMER repeat register value.  <a href="#ga8012c191a62ae300457d246f6fd13c04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LETIMER.html#ga99d89e7b494ea6d0a30be57444a7ba2a">LETIMER_RepeatSet</a> (LETIMER_TypeDef *letimer, unsigned int rep, uint32_t value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set LETIMER repeat counter register value.  <a href="#ga99d89e7b494ea6d0a30be57444a7ba2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LETIMER.html#gaf7209283bdf0e32dd3983d2fbb078d20">LETIMER_Reset</a> (LETIMER_TypeDef *letimer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset LETIMER to same state as after a HW reset.  <a href="#gaf7209283bdf0e32dd3983d2fbb078d20"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Low Energy Timer (LETIMER) Peripheral API. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gaa409061c5239d936cd67b4d578c054b3"></a><!-- doxytag: member="em_letimer.h::LETIMER_INIT_DEFAULT" ref="gaa409061c5239d936cd67b4d578c054b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LETIMER_INIT_DEFAULT</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{ <span class="keyword">true</span>,               <span class="comment">/* Enable timer when init complete. */</span>                  \
    <span class="keyword">false</span>,              <span class="comment">/* Stop counter during debug halt. */</span>                   \
    <span class="keyword">false</span>,              <span class="comment">/* Do not start counting on RTC COMP0 match. */</span>         \
    <span class="keyword">false</span>,              <span class="comment">/* Do not start counting on RTC COMP1 match. */</span>         \
    <span class="keyword">false</span>,              <span class="comment">/* Do not load COMP0 into CNT on underflow. */</span>          \
    <span class="keyword">false</span>,              <span class="comment">/* Do not load COMP1 into COMP0 when REP0 reaches 0. */</span> \
    0,                  <span class="comment">/* Idle value 0 for output 0. */</span>                        \
    0,                  <span class="comment">/* Idle value 0 for output 1. */</span>                        \
    <a class="code" href="group__LETIMER.html#gga7e794807b846cd4764aa5ff96e259ba7a265c11a5fd587fa4abb5a92253152a32">letimerUFOANone</a>,    <span class="comment">/* No action on underflow on output 0. */</span>               \
    <a class="code" href="group__LETIMER.html#gga7e794807b846cd4764aa5ff96e259ba7a265c11a5fd587fa4abb5a92253152a32">letimerUFOANone</a>,    <span class="comment">/* No action on underflow on output 1. */</span>               \
    <a class="code" href="group__LETIMER.html#gga621d39064a03e229a02e2c33fd815eb2aecd049f93ca363cf8c8c4569ad811a9b">letimerRepeatFree</a>   <span class="comment">/* Count until stopped by SW. */</span>                        \
  }
</pre></div><p>Default config for LETIMER init structure. </p>

<p>Definition at line <a class="el" href="em__letimer_8h_source.html#l00113">113</a> of file <a class="el" href="em__letimer_8h_source.html">em_letimer.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga621d39064a03e229a02e2c33fd815eb2"></a><!-- doxytag: member="em_letimer.h::LETIMER_RepeatMode_TypeDef" ref="ga621d39064a03e229a02e2c33fd815eb2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__LETIMER.html#ga621d39064a03e229a02e2c33fd815eb2">LETIMER_RepeatMode_TypeDef</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Repeat mode. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga621d39064a03e229a02e2c33fd815eb2aecd049f93ca363cf8c8c4569ad811a9b"></a><!-- doxytag: member="letimerRepeatFree" ref="gga621d39064a03e229a02e2c33fd815eb2aecd049f93ca363cf8c8c4569ad811a9b" args="" -->letimerRepeatFree</em>&nbsp;</td><td>
<p>Count until stopped by SW. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga621d39064a03e229a02e2c33fd815eb2a63dd96017a9e751c8cf5bfbd6ad9cf25"></a><!-- doxytag: member="letimerRepeatOneshot" ref="gga621d39064a03e229a02e2c33fd815eb2a63dd96017a9e751c8cf5bfbd6ad9cf25" args="" -->letimerRepeatOneshot</em>&nbsp;</td><td>
<p>Count REP0 times. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga621d39064a03e229a02e2c33fd815eb2a7bc26aed4618fc9209e44d40435aa05d"></a><!-- doxytag: member="letimerRepeatBuffered" ref="gga621d39064a03e229a02e2c33fd815eb2a7bc26aed4618fc9209e44d40435aa05d" args="" -->letimerRepeatBuffered</em>&nbsp;</td><td>
<p>Count REP0 times, if REP1 has been written to, it is loaded into REP0 when REP0 is about to be decremented to 0. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga621d39064a03e229a02e2c33fd815eb2a80f3d6cab367aa9ab2e153176bbecf00"></a><!-- doxytag: member="letimerRepeatDouble" ref="gga621d39064a03e229a02e2c33fd815eb2a80f3d6cab367aa9ab2e153176bbecf00" args="" -->letimerRepeatDouble</em>&nbsp;</td><td>
<p>Run as long as both REP0 and REP1 are not 0. Both REP0 and REP1 are decremented when counter underflows. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="em__letimer_8h_source.html#l00060">60</a> of file <a class="el" href="em__letimer_8h_source.html">em_letimer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga7e794807b846cd4764aa5ff96e259ba7"></a><!-- doxytag: member="em_letimer.h::LETIMER_UFOA_TypeDef" ref="ga7e794807b846cd4764aa5ff96e259ba7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__LETIMER.html#ga7e794807b846cd4764aa5ff96e259ba7">LETIMER_UFOA_TypeDef</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Underflow action on output. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga7e794807b846cd4764aa5ff96e259ba7a265c11a5fd587fa4abb5a92253152a32"></a><!-- doxytag: member="letimerUFOANone" ref="gga7e794807b846cd4764aa5ff96e259ba7a265c11a5fd587fa4abb5a92253152a32" args="" -->letimerUFOANone</em>&nbsp;</td><td>
<p>No output action. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7e794807b846cd4764aa5ff96e259ba7ab5fab86cea7ea60d6a614c1cd85febce"></a><!-- doxytag: member="letimerUFOAToggle" ref="gga7e794807b846cd4764aa5ff96e259ba7ab5fab86cea7ea60d6a614c1cd85febce" args="" -->letimerUFOAToggle</em>&nbsp;</td><td>
<p>Toggle output when counter underflows. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7e794807b846cd4764aa5ff96e259ba7a7a3c257077a97dfc45a3020892f0120f"></a><!-- doxytag: member="letimerUFOAPulse" ref="gga7e794807b846cd4764aa5ff96e259ba7a7a3c257077a97dfc45a3020892f0120f" args="" -->letimerUFOAPulse</em>&nbsp;</td><td>
<p>Hold output one LETIMER clock cycle when counter underflows. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7e794807b846cd4764aa5ff96e259ba7aa0547d98df77e356629131291036f787"></a><!-- doxytag: member="letimerUFOAPwm" ref="gga7e794807b846cd4764aa5ff96e259ba7aa0547d98df77e356629131291036f787" args="" -->letimerUFOAPwm</em>&nbsp;</td><td>
<p>Set output idle when counter underflows, and active when matching COMP1. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="em__letimer_8h_source.html#l00080">80</a> of file <a class="el" href="em__letimer_8h_source.html">em_letimer.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga8def6260e3c54ec6dac11581dcd7c1c5"></a><!-- doxytag: member="em_letimer.h::LETIMER_CompareGet" ref="ga8def6260e3c54ec6dac11581dcd7c1c5" args="(LETIMER_TypeDef *letimer, unsigned int comp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LETIMER_CompareGet </td>
          <td>(</td>
          <td class="paramtype">LETIMER_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>letimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>comp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get LETIMER compare register value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>letimer</em>&nbsp;</td><td>Pointer to LETIMER peripheral register block</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>comp</em>&nbsp;</td><td>Compare register to get, either 0 or 1</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Compare register value, 0 if invalid register selected. </dd></dl>

<p>Definition at line <a class="el" href="em__letimer_8c_source.html#l00124">124</a> of file <a class="el" href="em__letimer_8c_source.html">em_letimer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga5881f97abb64700592a23e213edeba21"></a><!-- doxytag: member="em_letimer.h::LETIMER_CompareSet" ref="ga5881f97abb64700592a23e213edeba21" args="(LETIMER_TypeDef *letimer, unsigned int comp, uint32_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LETIMER_CompareSet </td>
          <td>(</td>
          <td class="paramtype">LETIMER_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>letimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set LETIMER compare register value. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The setting of a compare register requires synchronization into the low frequency domain. If the same register is modified before a previous update has completed, this function will stall until the previous synchronization has completed. This only applies to the Gecko Family, see comment in the LETIMER_Sync() internal function call.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>letimer</em>&nbsp;</td><td>Pointer to LETIMER peripheral register block</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>comp</em>&nbsp;</td><td>Compare register to set, either 0 or 1</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Initialization value (&lt;= 0x0000ffff) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__letimer_8c_source.html#l00171">171</a> of file <a class="el" href="em__letimer_8c_source.html">em_letimer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga50ca4ff31c5eee289cb249fd160683f2"></a><!-- doxytag: member="em_letimer.h::LETIMER_CounterGet" ref="ga50ca4ff31c5eee289cb249fd160683f2" args="(LETIMER_TypeDef *letimer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LETIMER_CounterGet </td>
          <td>(</td>
          <td class="paramtype">LETIMER_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>letimer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get LETIMER counter value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>letimer</em>&nbsp;</td><td>Pointer to LETIMER peripheral register block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current LETIMER counter value. </dd></dl>

<p>Definition at line <a class="el" href="em__letimer_8h_source.html#l00148">148</a> of file <a class="el" href="em__letimer_8h_source.html">em_letimer.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaca64117c08fbb558eb2feb300cef0621"></a><!-- doxytag: member="em_letimer.h::LETIMER_Enable" ref="gaca64117c08fbb558eb2feb300cef0621" args="(LETIMER_TypeDef *letimer, bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LETIMER_Enable </td>
          <td>(</td>
          <td class="paramtype">LETIMER_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>letimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start/stop LETIMER. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The enabling/disabling of the LETIMER modifies the LETIMER CMD register which requires synchronization into the low frequency domain. If this register is modified before a previous update to the same register has completed, this function will stall until the previous synchronization has completed. This only applies to the Gecko Family, see comment in the LETIMER_Sync() internal function call.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>letimer</em>&nbsp;</td><td>Pointer to LETIMER peripheral register block.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>enable</em>&nbsp;</td><td>true to enable counting, false to disable. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__letimer_8c_source.html#l00224">224</a> of file <a class="el" href="em__letimer_8c_source.html">em_letimer.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf4a565497669b1852de043374173c288"></a><!-- doxytag: member="em_letimer.h::LETIMER_FreezeEnable" ref="gaf4a565497669b1852de043374173c288" args="(LETIMER_TypeDef *letimer, bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LETIMER_FreezeEnable </td>
          <td>(</td>
          <td class="paramtype">LETIMER_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>letimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LETIMER register synchronization freeze control. </p>
<p>Some LETIMER registers require synchronization into the low frequency (LF) domain. The freeze feature allows for several such registers to be modified before passing them to the LF domain simultaneously (which takes place when the freeze mode is disabled).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>When enabling freeze mode, this function will wait for all current ongoing LETIMER synchronization to LF domain to complete (Normally synchronization will not be in progress.) However for this reason, when using freeze mode, modifications of registers requiring LF synchronization should be done within one freeze enable/disable block to avoid unecessary stalling.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>letimer</em>&nbsp;</td><td>Pointer to LETIMER peripheral register block.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>enable</em>&nbsp;</td><td><ul>
<li>true - enable freeze, modified registers are not propagated to the LF domain </li>
<li>false - disables freeze, modified registers are propagated to LF domain </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__letimer_8c_source.html#l00271">271</a> of file <a class="el" href="em__letimer_8c_source.html">em_letimer.c</a>.</p>

<p>Referenced by <a class="el" href="em__letimer_8c_source.html#l00509">LETIMER_Reset()</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LETIMER_gaf4a565497669b1852de043374173c288_icgraph.png" border="0" usemap="#group__LETIMER_gaf4a565497669b1852de043374173c288_icgraph_map" alt=""></div>
<map name="group__LETIMER_gaf4a565497669b1852de043374173c288_icgraph_map" id="group__LETIMER_gaf4a565497669b1852de043374173c288_icgraph">
<area shape="rect" id="node2" href="group__LETIMER.html#gaf7209283bdf0e32dd3983d2fbb078d20" title="Reset LETIMER to same state as after a HW reset." alt="" coords="225,5,343,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaa4e7e28b4b04595a991a93b9e76c9919"></a><!-- doxytag: member="em_letimer.h::LETIMER_Init" ref="gaa4e7e28b4b04595a991a93b9e76c9919" args="(LETIMER_TypeDef *letimer, const LETIMER_Init_TypeDef *init)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LETIMER_Init </td>
          <td>(</td>
          <td class="paramtype">LETIMER_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>letimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structLETIMER__Init__TypeDef.html">LETIMER_Init_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>init</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize LETIMER. </p>
<p>Note that the compare/repeat values must be set separately with <a class="el" href="group__LETIMER.html#ga5881f97abb64700592a23e213edeba21" title="Set LETIMER compare register value.">LETIMER_CompareSet()</a> and <a class="el" href="group__LETIMER.html#ga99d89e7b494ea6d0a30be57444a7ba2a" title="Set LETIMER repeat counter register value.">LETIMER_RepeatSet()</a>. That should probably be done prior to the use of this function if configuring the LETIMER to start when initialization is completed.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The initialization of the LETIMER modifies the LETIMER CTRL/CMD registers which require synchronization into the low frequency domain. If any of those registers are modified before a previous update to the same register has completed, this function will stall until the previous synchronization has completed. This only applies to the Gecko Family, see comment in the LETIMER_Sync() internal function call.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>letimer</em>&nbsp;</td><td>Pointer to LETIMER peripheral register block.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>init</em>&nbsp;</td><td>Pointer to LETIMER initialization structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__letimer_8c_source.html#l00320">320</a> of file <a class="el" href="em__letimer_8c_source.html">em_letimer.c</a>.</p>

<p>References <a class="el" href="em__letimer_8h_source.html#l00104">LETIMER_Init_TypeDef::bufTop</a>, <a class="el" href="em__letimer_8h_source.html#l00103">LETIMER_Init_TypeDef::comp0Top</a>, <a class="el" href="em__letimer_8h_source.html#l00100">LETIMER_Init_TypeDef::debugRun</a>, <a class="el" href="em__letimer_8h_source.html#l00099">LETIMER_Init_TypeDef::enable</a>, <a class="el" href="em__letimer_8h_source.html#l00105">LETIMER_Init_TypeDef::out0Pol</a>, <a class="el" href="em__letimer_8h_source.html#l00106">LETIMER_Init_TypeDef::out1Pol</a>, <a class="el" href="em__letimer_8h_source.html#l00109">LETIMER_Init_TypeDef::repMode</a>, <a class="el" href="em__letimer_8h_source.html#l00101">LETIMER_Init_TypeDef::rtcComp0Enable</a>, <a class="el" href="em__letimer_8h_source.html#l00102">LETIMER_Init_TypeDef::rtcComp1Enable</a>, <a class="el" href="em__letimer_8h_source.html#l00107">LETIMER_Init_TypeDef::ufoa0</a>, and <a class="el" href="em__letimer_8h_source.html#l00108">LETIMER_Init_TypeDef::ufoa1</a>.</p>

</div>
</div>
<a class="anchor" id="ga73948168b9c0345e75551ed3f8115474"></a><!-- doxytag: member="em_letimer.h::LETIMER_IntClear" ref="ga73948168b9c0345e75551ed3f8115474" args="(LETIMER_TypeDef *letimer, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LETIMER_IntClear </td>
          <td>(</td>
          <td class="paramtype">LETIMER_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>letimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear one or more pending LETIMER interrupts. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>letimer</em>&nbsp;</td><td>Pointer to LETIMER peripheral register block.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Pending LETIMER interrupt source to clear. Use a bitwise logic OR combination of valid interrupt flags for the LETIMER module (LETIMER_IF_nnn). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__letimer_8h_source.html#l00171">171</a> of file <a class="el" href="em__letimer_8h_source.html">em_letimer.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac559ba136bfd11379a1dc12cc45cc82e"></a><!-- doxytag: member="em_letimer.h::LETIMER_IntDisable" ref="gac559ba136bfd11379a1dc12cc45cc82e" args="(LETIMER_TypeDef *letimer, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LETIMER_IntDisable </td>
          <td>(</td>
          <td class="paramtype">LETIMER_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>letimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable one or more LETIMER interrupts. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>letimer</em>&nbsp;</td><td>Pointer to LETIMER peripheral register block.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>LETIMER interrupt sources to disable. Use a bitwise logic OR combination of valid interrupt flags for the LETIMER module (LETIMER_IF_nnn). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__letimer_8h_source.html#l00188">188</a> of file <a class="el" href="em__letimer_8h_source.html">em_letimer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga11110bb53b566e017a9248a4a8946963"></a><!-- doxytag: member="em_letimer.h::LETIMER_IntEnable" ref="ga11110bb53b566e017a9248a4a8946963" args="(LETIMER_TypeDef *letimer, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LETIMER_IntEnable </td>
          <td>(</td>
          <td class="paramtype">LETIMER_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>letimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable one or more LETIMER interrupts. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Depending on the use, a pending interrupt may already be set prior to enabling the interrupt. Consider using <a class="el" href="group__LETIMER.html#ga73948168b9c0345e75551ed3f8115474" title="Clear one or more pending LETIMER interrupts.">LETIMER_IntClear()</a> prior to enabling if such a pending interrupt should be ignored.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>letimer</em>&nbsp;</td><td>Pointer to LETIMER peripheral register block.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>LETIMER interrupt sources to enable. Use a bitwise logic OR combination of valid interrupt flags for the LETIMER module (LETIMER_IF_nnn). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__letimer_8h_source.html#l00210">210</a> of file <a class="el" href="em__letimer_8h_source.html">em_letimer.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafc3fe4be7e3a67c4403c0c0a9966a893"></a><!-- doxytag: member="em_letimer.h::LETIMER_IntGet" ref="gafc3fe4be7e3a67c4403c0c0a9966a893" args="(LETIMER_TypeDef *letimer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LETIMER_IntGet </td>
          <td>(</td>
          <td class="paramtype">LETIMER_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>letimer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get pending LETIMER interrupt flags. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The event bits are not cleared by the use of this function.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>letimer</em>&nbsp;</td><td>Pointer to LETIMER peripheral register block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>LETIMER interrupt sources pending. A bitwise logic OR combination of valid interrupt flags for the LETIMER module (LETIMER_IF_nnn). </dd></dl>

<p>Definition at line <a class="el" href="em__letimer_8h_source.html#l00230">230</a> of file <a class="el" href="em__letimer_8h_source.html">em_letimer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga8ad490c965b096e4bde9ebdc2a16ec05"></a><!-- doxytag: member="em_letimer.h::LETIMER_IntSet" ref="ga8ad490c965b096e4bde9ebdc2a16ec05" args="(LETIMER_TypeDef *letimer, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LETIMER_IntSet </td>
          <td>(</td>
          <td class="paramtype">LETIMER_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>letimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set one or more pending LETIMER interrupts from SW. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>letimer</em>&nbsp;</td><td>Pointer to LETIMER peripheral register block.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>LETIMER interrupt sources to set to pending. Use a bitwise logic OR combination of valid interrupt flags for the LETIMER module (LETIMER_IF_nnn). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__letimer_8h_source.html#l00247">247</a> of file <a class="el" href="em__letimer_8h_source.html">em_letimer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga8012c191a62ae300457d246f6fd13c04"></a><!-- doxytag: member="em_letimer.h::LETIMER_RepeatGet" ref="ga8012c191a62ae300457d246f6fd13c04" args="(LETIMER_TypeDef *letimer, unsigned int rep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LETIMER_RepeatGet </td>
          <td>(</td>
          <td class="paramtype">LETIMER_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>letimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>rep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get LETIMER repeat register value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>letimer</em>&nbsp;</td><td>Pointer to LETIMER peripheral register block</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rep</em>&nbsp;</td><td>Repeat register to get, either 0 or 1</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Repeat register value, 0 if invalid register selected. </dd></dl>

<p>Definition at line <a class="el" href="em__letimer_8c_source.html#l00408">408</a> of file <a class="el" href="em__letimer_8c_source.html">em_letimer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga99d89e7b494ea6d0a30be57444a7ba2a"></a><!-- doxytag: member="em_letimer.h::LETIMER_RepeatSet" ref="ga99d89e7b494ea6d0a30be57444a7ba2a" args="(LETIMER_TypeDef *letimer, unsigned int rep, uint32_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LETIMER_RepeatSet </td>
          <td>(</td>
          <td class="paramtype">LETIMER_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>letimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set LETIMER repeat counter register value. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The setting of a repeat counter register requires synchronization into the low frequency domain. If the same register is modified before a previous update has completed, this function will stall until the previous synchronization has completed. This only applies to the Gecko Family, see comment in the LETIMER_Sync() internal function call.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>letimer</em>&nbsp;</td><td>Pointer to LETIMER peripheral register block</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rep</em>&nbsp;</td><td>Repeat counter register to set, either 0 or 1</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Initialization value (&lt;= 0x0000ffff) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__letimer_8c_source.html#l00455">455</a> of file <a class="el" href="em__letimer_8c_source.html">em_letimer.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf7209283bdf0e32dd3983d2fbb078d20"></a><!-- doxytag: member="em_letimer.h::LETIMER_Reset" ref="gaf7209283bdf0e32dd3983d2fbb078d20" args="(LETIMER_TypeDef *letimer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LETIMER_Reset </td>
          <td>(</td>
          <td class="paramtype">LETIMER_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>letimer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset LETIMER to same state as after a HW reset. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The ROUTE register is NOT reset by this function, in order to allow for centralized setup of this feature.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>letimer</em>&nbsp;</td><td>Pointer to LETIMER peripheral register block. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__letimer_8c_source.html#l00509">509</a> of file <a class="el" href="em__letimer_8c_source.html">em_letimer.c</a>.</p>

<p>References <a class="el" href="em__letimer_8c_source.html#l00271">LETIMER_FreezeEnable()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__LETIMER_gaf7209283bdf0e32dd3983d2fbb078d20_cgraph.png" border="0" usemap="#group__LETIMER_gaf7209283bdf0e32dd3983d2fbb078d20_cgraph_map" alt=""></div>
<map name="group__LETIMER_gaf7209283bdf0e32dd3983d2fbb078d20_cgraph_map" id="group__LETIMER_gaf7209283bdf0e32dd3983d2fbb078d20_cgraph">
<area shape="rect" id="node2" href="group__LETIMER.html#gaf4a565497669b1852de043374173c288" title="LETIMER register synchronization freeze control." alt="" coords="174,5,343,32"/></map>
</div>
</p>

</div>
</div>
</div>
<div id="footer">
<hr size="1"><address style="text-align: right;"><small>
Generated on Thu May 28 06:10:09 2015</small> for Silicon Labs EFM32 emlib Peripheral Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a><small> 1.6.3 </small></address></div>
</body>
</html>
